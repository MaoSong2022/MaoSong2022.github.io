<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Scaling Law on Mao Song(毛松)'s Homepage</title><link>https://maosong2022.github.io/tags/scaling-law/</link><description>Recent content in Scaling Law on Mao Song(毛松)'s Homepage</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 22 Oct 2025 14:39:23 +0800</lastBuildDate><atom:link href="https://maosong2022.github.io/tags/scaling-law/index.xml" rel="self" type="application/rss+xml"/><item><title>Chinchilla Scaling Law</title><link>https://maosong2022.github.io/p/chinchilla-scaling-law/</link><pubDate>Wed, 22 Oct 2025 14:39:23 +0800</pubDate><guid>https://maosong2022.github.io/p/chinchilla-scaling-law/</guid><description>&lt;h2 id="introduction">Introduction
&lt;/h2>&lt;p>本文中关注的研究问题为：&lt;/p>
&lt;blockquote>
&lt;p>给定一个 FLOPs budget, 如何平衡 model size 和 dataset size 之间的关系？&lt;/p>
&lt;/blockquote>
&lt;p>即，我们希望求解如下优化问题：&lt;/p>
$$
N_{opt}(C), D_{opt}(C) =\arg\min_{N,D,\ \mathrm{s.t.}\ FLOPs(N,D)=C} L(N,D)
$$&lt;p>作者通过训练 400 多个模型，构建了对应的 scaling law.&lt;/p>
&lt;p>已有工作如 &lt;a class="link" href="https://maosong.website/p/kaplan-scaling-law/" target="_blank" rel="noopener"
>Kaplan scaling law&lt;/a> 已经发现模型参数和大语言模型表现之间的关系，一个结论就是计算最优并不代表达到最优的 loss. 在本文中，作者也有相同结论，但是作者认为大模型应该使用比 &lt;a class="link" href="https://maosong.website/p/kaplan-scaling-law/" target="_blank" rel="noopener"
>Kaplan scaling law&lt;/a> 推荐的更多的 training token. 基于这个发现，作者训练了 Chinchilla, 一个 70B 的 LLM, Chinchilla 相比 Gopher 表现有了大幅度的提升。&lt;/p>
&lt;h2 id="scaling-law">Scaling Law
&lt;/h2>&lt;h3 id="fix-model-size-and-very-dataset-size">Fix Model Size and Very Dataset Size
&lt;/h3>&lt;p>这个方法中，作者通过改变训练步数，来研究 FLOPs 与模型表现之间的关系，结果如下图所示&lt;/p>
&lt;p>&lt;img src="https://maosong2022.github.io/p/chinchilla-scaling-law/Chinchilla-Training-curve-envelope.png"
width="3018"
height="1304"
srcset="https://maosong2022.github.io/p/chinchilla-scaling-law/Chinchilla-Training-curve-envelope_hu10567536964506360272.png 480w, https://maosong2022.github.io/p/chinchilla-scaling-law/Chinchilla-Training-curve-envelope_hu16266655799417657314.png 1024w"
loading="lazy"
alt="Training Curve envelope"
class="gallery-image"
data-flex-grow="231"
data-flex-basis="555px"
>&lt;/p>
&lt;p>通过对实验结果进行拟合，作者发现存在关系 $N_{opt}(C)\propto C^a$ 以及 $D_{opt}(C)\propto C^b$, 拟合的结果为 $a=b=0.5$.&lt;/p>
&lt;h3 id="isoflops-profiles">IsoFLOPS Profiles
&lt;/h3>&lt;p>这个方法中，作者使用了不同的模型大小以及算力来构建最优模型参数量与算力之间的关系。作者给定 9 个算力配置，然后选取不同参数量的模型，训练的 token 数由算力和模型参数量决定，实验结果如下图所示&lt;/p>
&lt;p>&lt;img src="https://maosong2022.github.io/p/chinchilla-scaling-law/Chinchilla-IsoFLOP-curves.png"
width="3018"
height="1396"
srcset="https://maosong2022.github.io/p/chinchilla-scaling-law/Chinchilla-IsoFLOP-curves_hu12964383356718639356.png 480w, https://maosong2022.github.io/p/chinchilla-scaling-law/Chinchilla-IsoFLOP-curves_hu11328230484318679329.png 1024w"
loading="lazy"
alt="IsoFLOP curves"
class="gallery-image"
data-flex-grow="216"
data-flex-basis="518px"
>&lt;/p>
&lt;p>结果显示，不同大小的模型的表现 (loss) 随算力上升先下降后上升。因此给定算力，存在一个最优的 model size. 作者基于拟合出来的曲线得到了 Gopher 使用的算力配置下的最优 model size 和 training tokens. 同样的，作者得到 $a=0.49,b=0.51$.&lt;/p>
&lt;h3 id="fitting-a-parametric-loss-function">Fitting a Parametric Loss Function
&lt;/h3>&lt;p>这个方法中，作者对 $L(N,D)$ 进行建模，作者使用了如下的公式&lt;/p>
$$
L(N,D) = E + \frac{A}{N^{\alpha}} + \frac{B}{D^{\beta}}
$$&lt;p>第一项代表了建模的误差，第二项代表了数据集充分大损失与模型参数之间的关系，第三项代表了当模型充分训练时，损失与数据集大小之间的关系。&lt;/p>
&lt;p>为了求解 $(A,B,E,\alpha,\beta)$, 作者基于训练收集到的数据 $L(N_i,D_i)$, 通过 L-BFGS 算法来最小化 Huber loss 进行求解，结果得到 $(A,B,E,\alpha,\beta)=(1.69, 406.4, 410.7, 0.34, 0.28)$.&lt;/p>
&lt;p>将结果带入带上面的表达式中，然后求出梯度为 0 的点，就得到&lt;/p>
$$
N_{opt}(C) = G\left(\frac C6\right)^a, D_{opt}(C) = G^{-1}\left(\frac C6\right)^b, \text{ where }G=\left(\frac{\alpha A}{\beta B}\right)^{1/(\alpha+\beta)}, a=\frac{\beta}{\alpha+\beta}, b=\frac{\alpha}{\alpha+\beta}
$$&lt;p>带入数值之后就得到 $a=0.46$, $b=0.54$. 作者对结果可视化如下图所示，左图是拟合曲线的 Contour plot, 右图对左图的一个切片&lt;/p>
&lt;p>&lt;img src="https://maosong2022.github.io/p/chinchilla-scaling-law/Chinchilla-Parametric-fit.png"
width="2980"
height="1284"
srcset="https://maosong2022.github.io/p/chinchilla-scaling-law/Chinchilla-Parametric-fit_hu11197797298351948532.png 480w, https://maosong2022.github.io/p/chinchilla-scaling-law/Chinchilla-Parametric-fit_hu10910264691183016639.png 1024w"
loading="lazy"
alt="Parametric fit"
class="gallery-image"
data-flex-grow="232"
data-flex-basis="557px"
>&lt;/p>
&lt;h3 id="optimal-model-scaling">Optimal Model Scaling
&lt;/h3>&lt;p>作者将三种方法的结果以及 &lt;a class="link" href="https://maosong.website/p/kaplan-scaling-law/" target="_blank" rel="noopener"
>Kaplan scaling law&lt;/a> 的结果总结放在下表中，作者假设 $N_{opt}(C)\propto C^a$ 以及 $D_{opt}(C)\propto C^b$&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Approach&lt;/th>
&lt;th>$a$&lt;/th>
&lt;th>$b$&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Kaplan&lt;/td>
&lt;td>0.73&lt;/td>
&lt;td>0.26&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Approach 1&lt;/td>
&lt;td>0.50&lt;/td>
&lt;td>0.50&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Approach 2&lt;/td>
&lt;td>0.49&lt;/td>
&lt;td>0.51&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Approach 3&lt;/td>
&lt;td>0.46&lt;/td>
&lt;td>0.54&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>结果表明，三种方法的结论差不多：model size 和 dataset size 增长 debility 差不多。&lt;/p>
&lt;p>作者因此给出来的不同模型大小所需要的算力以及 token, 结果如下表所示&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Parameters&lt;/th>
&lt;th>Approach 1&lt;/th>
&lt;th>&lt;/th>
&lt;th>Approach 2&lt;/th>
&lt;th>&lt;/th>
&lt;th>Approach 3&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>FLOPs&lt;/td>
&lt;td>Tokens&lt;/td>
&lt;td>FLOPs&lt;/td>
&lt;td>Tokens&lt;/td>
&lt;td>FLOPs&lt;/td>
&lt;td>Tokens&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>400 M&lt;/td>
&lt;td>1.92e+19&lt;/td>
&lt;td>8.0 B&lt;/td>
&lt;td>1.84e+19&lt;/td>
&lt;td>7.7 B&lt;/td>
&lt;td>1.84e+19&lt;/td>
&lt;td>7.7 B&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1 B&lt;/td>
&lt;td>1.21e+20&lt;/td>
&lt;td>20.2 B&lt;/td>
&lt;td>1.20e+20&lt;/td>
&lt;td>20.0 B&lt;/td>
&lt;td>1.20e+20&lt;/td>
&lt;td>20.0 B&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>10 B&lt;/td>
&lt;td>1.23e+22&lt;/td>
&lt;td>205.1 B&lt;/td>
&lt;td>1.32e+22&lt;/td>
&lt;td>219.5 B&lt;/td>
&lt;td>1.32e+22&lt;/td>
&lt;td>219.5 B&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>67 B&lt;/td>
&lt;td>5.76e+23&lt;/td>
&lt;td>1.5 T&lt;/td>
&lt;td>6.88e+23&lt;/td>
&lt;td>1.7 T&lt;/td>
&lt;td>6.88e+23&lt;/td>
&lt;td>1.7 T&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>175 B&lt;/td>
&lt;td>3.85e+24&lt;/td>
&lt;td>3.7 T&lt;/td>
&lt;td>4.54e+24&lt;/td>
&lt;td>4.3 T&lt;/td>
&lt;td>4.54e+24&lt;/td>
&lt;td>4.3 T&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>280 B&lt;/td>
&lt;td>9.90e+24&lt;/td>
&lt;td>5.9 T&lt;/td>
&lt;td>1.18e+25&lt;/td>
&lt;td>7.1 T&lt;/td>
&lt;td>1.18e+25&lt;/td>
&lt;td>7.1 T&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>520 B&lt;/td>
&lt;td>3.43e+25&lt;/td>
&lt;td>11.0 T&lt;/td>
&lt;td>4.19e+25&lt;/td>
&lt;td>13.4 T&lt;/td>
&lt;td>4.19e+25&lt;/td>
&lt;td>13.4 T&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1 T&lt;/td>
&lt;td>1.27e+26&lt;/td>
&lt;td>21.2 T&lt;/td>
&lt;td>1.59e+26&lt;/td>
&lt;td>26.5 T&lt;/td>
&lt;td>1.59e+26&lt;/td>
&lt;td>26.5 T&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>10 T&lt;/td>
&lt;td>1.30e+28&lt;/td>
&lt;td>216.2 T&lt;/td>
&lt;td>1.75e+28&lt;/td>
&lt;td>292.0 T&lt;/td>
&lt;td>1.75e+28&lt;/td>
&lt;td>292.0 T&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>作者基于发现的 scaling law, 对已有模型进行了探究，发现现有的大模型都存在 under-training 的现象，结果如下图所示&lt;/p>
&lt;p>&lt;img src="https://maosong2022.github.io/p/chinchilla-scaling-law/Chinchilla-Overlaied-predictions.png"
width="2422"
height="1284"
srcset="https://maosong2022.github.io/p/chinchilla-scaling-law/Chinchilla-Overlaied-predictions_hu5657720287792187032.png 480w, https://maosong2022.github.io/p/chinchilla-scaling-law/Chinchilla-Overlaied-predictions_hu2560641788537084569.png 1024w"
loading="lazy"
alt="Overlaid predictions"
class="gallery-image"
data-flex-grow="188"
data-flex-basis="452px"
>&lt;/p>
&lt;p>实验结果显示，现有的大模型的 size 应该更小（或者需要更大的算力）。作者最终的结论就是，现有的比较小的模型，需要更多的算力才能达到更好的表现。&lt;/p>
&lt;h2 id="chinchilla">Chinchilla
&lt;/h2>&lt;p>基于上一节的发现，作者提出了 Chinchilla, 一个 70B 的模型，训练使用了 1.4T token. 训练的数据集为 MassiveText 的扩展版本，训练使用的优化器为 AdamW, tokenizer 为 SentencePiece.&lt;/p>
&lt;p>模型配置如下表所示&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Model&lt;/th>
&lt;th>Layers&lt;/th>
&lt;th>Number Heads&lt;/th>
&lt;th>Key/Value Size&lt;/th>
&lt;th>dmodel&lt;/th>
&lt;th>Max LR&lt;/th>
&lt;th>Batch Size&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Gopher 280B&lt;/td>
&lt;td>80&lt;/td>
&lt;td>128&lt;/td>
&lt;td>128&lt;/td>
&lt;td>16384&lt;/td>
&lt;td>$4\times 10^{-5}$&lt;/td>
&lt;td>$3M\to6M$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Chinchilla 70B&lt;/td>
&lt;td>80&lt;/td>
&lt;td>64&lt;/td>
&lt;td>128&lt;/td>
&lt;td>8192&lt;/td>
&lt;td>$1\times 10^{-5}$&lt;/td>
&lt;td>$1.5M\to3M$&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="ablation-study">Ablation Study
&lt;/h3>&lt;p>&lt;strong>learning rate schedule&lt;/strong>
作者还通过 ablation study 发现，cosine learning rate cycle length 应该和训练步数差不多，当 cycle length 太长时，模型表现会下降。&lt;/p>
&lt;p>&lt;strong>Optimizer&lt;/strong>
作者对比了 &lt;a class="link" href="https://maosong.website/p/notes-on-adam/" target="_blank" rel="noopener"
>Adam&lt;/a> 和 &lt;a class="link" href="https://maosong.website/p/notes-on-adamw/" target="_blank" rel="noopener"
>AdamW&lt;/a> 的表现，结果发现，AdamW 的表现优于 Adam.&lt;/p>
&lt;p>&lt;strong>High Precision&lt;/strong>
训练时，作者使用了高精度也就是 &lt;code>float32&lt;/code> 来保存梯度的状态，结果显示，不管是 Adam 还是 AdamW, 使用高精度都可以提高模型的表现&lt;/p>
&lt;p>&lt;strong>Comparison with Kaplan&lt;/strong>
作者还对比了 Chinchilla 和 Kaplan 的预测结果，如下图所示&lt;/p>
&lt;p>&lt;img src="https://maosong2022.github.io/p/chinchilla-scaling-law/Chinchilla-Comparison-with-Kaplan.png"
width="2684"
height="1436"
srcset="https://maosong2022.github.io/p/chinchilla-scaling-law/Chinchilla-Comparison-with-Kaplan_hu507971005612149960.png 480w, https://maosong2022.github.io/p/chinchilla-scaling-law/Chinchilla-Comparison-with-Kaplan_hu5865122634259890514.png 1024w"
loading="lazy"
alt="Comparison with Kaplan"
class="gallery-image"
data-flex-grow="186"
data-flex-basis="448px"
>&lt;/p>
&lt;p>结果显示，基于 Chinchilla 预测得到的模型训练效果比 Kaplan 的更好。&lt;/p>
&lt;p>&lt;strong>Curvature of the FLOPs-frontier&lt;/strong>
作者发现，FLOP-minimal loss frontier 存在 curvature, 也就是小模型和大模型预测出来的曲线是不一样的，作者将结果展示在下图中&lt;/p>
&lt;p>&lt;img src="https://maosong2022.github.io/p/chinchilla-scaling-law/Chinchilla-curvature-of-FLOPs-frontier.png"
width="3012"
height="1570"
srcset="https://maosong2022.github.io/p/chinchilla-scaling-law/Chinchilla-curvature-of-FLOPs-frontier_hu14241032175010404049.png 480w, https://maosong2022.github.io/p/chinchilla-scaling-law/Chinchilla-curvature-of-FLOPs-frontier_hu704732338348992847.png 1024w"
loading="lazy"
alt="Curvature of the FLOPs-frontier"
class="gallery-image"
data-flex-grow="191"
data-flex-basis="460px"
>&lt;/p>
&lt;p>结果显示，从小模型拟合出来的结果比大模型拥有更高的算力使用效率，作者认为这是未来的一个研究方向。&lt;/p>
&lt;h2 id="conclusion">Conclusion
&lt;/h2>&lt;p>本文中作者重新探究了针对 LLM 的 scaling law, 作者发现已有的大模型都存在 under-training 的现象，也就是说，模型需要更多的训练 token, 具体来讲，model size scaling 和 dataset scaling 应该处于同一水平。作者基于这个结论，提出了 Chinchilla, 一个 70B 的 LLM, 其表现超过了 280B 的 LLM.&lt;/p>
&lt;h2 id="references">References
&lt;/h2>&lt;ul>
&lt;li>&lt;a class="link" href="http://arxiv.org/abs/2203.15556" target="_blank" rel="noopener"
>arxiv&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Kaplan Scaling Law</title><link>https://maosong2022.github.io/p/kaplan-scaling-law/</link><pubDate>Wed, 22 Oct 2025 14:10:52 +0800</pubDate><guid>https://maosong2022.github.io/p/kaplan-scaling-law/</guid><description>&lt;h2 id="introduction">Introduction
&lt;/h2>&lt;p>作者首先就总结了本文的发现，主要有以下几点：&lt;/p>
&lt;ol>
&lt;li>损失与模型的 scale , 即除开 embedding 的模型参数，数据集大小以及算力强相关，与 model shape 比如 depth 或者 width 关系不大&lt;/li>
&lt;li>scaling law 是非常光滑的，意味着 scaling law 是一个可预测的模型&lt;/li>
&lt;li>overfitting 普遍存在，当参数和数据集大小同时增加时，模型的表现会增加，但是当其中一个量固定时，提升就比较小。并且当我们将模型参数提升 8 倍时，我们只需要将数据集的大小提升 5 倍就可以避免过拟合&lt;/li>
&lt;li>训练的损失函数曲线与 model size 无关，因此我们可以预测给定大小模型的表现&lt;/li>
&lt;li>模型在测试集和训练集上的表现高度相关，因此我们可以基于训练集的损失来预测模型的表现&lt;/li>
&lt;li>大模型比小模型拥有更高的 sample efficiency, 即更小的训练步数就可以达到相同的表现&lt;/li>
&lt;li>convergence 不能说明一切，我们可以通过 early-stopping 来提高算力使用效率，避免模型花费过多的算力在较小的提升上&lt;/li>
&lt;li>最优的 batch size 与 loss 呈一个 power law 的关系&lt;/li>
&lt;/ol>
&lt;h3 id="notation">Notation
&lt;/h3>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Symbol&lt;/th>
&lt;th>Notation&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>$L$&lt;/td>
&lt;td>cross entropy loss&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$N$&lt;/td>
&lt;td>non-embedding parametters&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$B$&lt;/td>
&lt;td>batch size&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$S$&lt;/td>
&lt;td>number of training steps&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$C\approx 6NBS$&lt;/td>
&lt;td>estimate of total training compute&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$D$&lt;/td>
&lt;td>dataset size in tokens&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$B_{crit}$&lt;/td>
&lt;td>critical batch size&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$C_{\min}$&lt;/td>
&lt;td>estimate of the minimum compute to reach a given value of loss&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$S_{\min}$&lt;/td>
&lt;td>estimate of the minimum steps to reach a given value of loss&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$\alpha_X$&lt;/td>
&lt;td>power-law exponents for the scaling law of loss&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>$d$&lt;/td>
&lt;td>hidden size of the model&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>为了简便，后续未经特殊说明，我们说模型参数均指的是 non-embedding 的参数&lt;/p>
&lt;h3 id="scaling-law-overview">Scaling Law Overview
&lt;/h3>&lt;ol>
&lt;li>当数据集 $D$ 足够大时，损失与模型参数大小 $N$ 之间的关系为&lt;/li>
&lt;/ol>
$$
L(N) = \left(\frac{N_C}{N}\right)^{\alpha_N}, \alpha_N\sim 0.076, N_C\sim 8.8\times 10^{13}
$$&lt;ol start="2">
&lt;li>给定模型参数大小 $N$ , 损失与数据集大小 $D$ 之间的关系为&lt;/li>
&lt;/ol>
$$
L(D) = \left(\frac{D_C}{D}\right)^{\alpha_D}, \alpha_D\sim 0.095, D_C\sim 5.4\times 10^{13}
$$&lt;ol start="3">
&lt;li>给定足够大的数据集 $D$ 和最优模型大小 $N$ 时，损失与算力 $C$ 之间的关系为&lt;/li>
&lt;/ol>
$$
L(C_{\min}) = \left(\frac{C_C^{\min}}{C_{\min}}\right)^{\alpha_D}, \alpha_C^{\min}\sim 0.050, C_C^{\min}\sim 3.1\times 10^{8}
$$&lt;p>作者在不同大小的数据集，算力，模型大小下进行了测试，结果发现 scaling 与模型的 shape, transformer 的超参数之间的关系比较小。$\alpha_N,\alpha_D,\alpha_C^{\min}$ 等决定了当我们 scale up 数据及大小，模型大小和算力时损失的变化情况。比如当我们将模型参数提升至 2 倍时，模型的损失会降低至原来的 $0.95$.&lt;/p>
&lt;p>基于发现 1 和 2, 作者发现当我们将模型的 size 提升至原来的 2 倍时，模型的数据集大小应该提升至原来的 $1.67$ 倍，具体关系为 $D\sim N^{0.74}$.&lt;/p>
&lt;p>作者使用了一个统一的公式来描述损失与数据及大小和模型参数大小之间的关系&lt;/p>
$$
L(N,D) = \left[\left(\frac{N_c}{N}\right)^{\frac{\alpha_N}{\alpha_D}}+ \frac{D_c}{D}\right]^{\alpha_D}
$$&lt;ol start="4">
&lt;li>当数据集充分大时，损失与模型参数大小以及更新步数 $S$ 的关系如下&lt;/li>
&lt;/ol>
$$
L(N, S) = \left(\frac{N_C}{N}\right)^{\alpha_N} +\left(\frac{S_C}{S_{\min}(S)}\right)^{\alpha_S}
$$&lt;p>这里 $S_C\approx 2.1\times 10^3$, $\alpha_S\approx 0.76$, $S_{\min}(S)$ 是估计出来的最小优化步数&lt;/p>
&lt;ol start="5">
&lt;li>最优的 batch size 与损失函数之间的关系如下&lt;/li>
&lt;/ol>
$$
B_{crit}(L) = \frac{B_*}{L^{1/\alpha_B}}, B_*\sim 2*10^8 \text{ tokens}, \alpha_B\sim 0.21
$$&lt;ol start="6">
&lt;li>给定算力 $C$ 且无其他限制时，模型参数，数据及大小，batch size 和更新参数与算力之间的关系如下&lt;/li>
&lt;/ol>
$$
N\propto C^{\alpha_C^{\min}/\alpha_N}, B\propto C^{\alpha_C^{\min}/\alpha_B}, S\propto C^{\alpha_C^{\min}/\alpha_S}, D=BS
$$&lt;p>其中&lt;/p>
$$
\alpha_C^{\min} = \frac{1}{\frac{1}{\alpha_S}+\frac{1}{\alpha_B}+\frac{1}{\alpha_N}}
$$&lt;p>实验的结果为 $N\propto C_{\min}^{0.73}$, $B\propto C_{\min}^{0.24}$ , $S\propto C_{\min}^{0.03}$. 也就是说，当我们提升算力时，提升模型的参数大小带来的收益是最高的。&lt;/p>
&lt;h2 id="background">Background
&lt;/h2>&lt;p>首先，transformer 的参数量通过计算可以得到&lt;/p>
$$
N\approx 2dn(2d+d_{ff}) = 12nd^2
$$&lt;p>这里 $d$ 是 hidden size, $n$ 是 layer 个数，$d_{ff}$ 是 MLP 的 hidden size, 这里我们 假设 $d_{ff}=4d$. 计算时我们丢掉了 bias 以及 LayerNorm 的参数量。具体计算过程见 &lt;a class="link" href="https://maosong.website/p/llm-parameter-computation/" target="_blank" rel="noopener"
>LLM parameter analysis&lt;/a>&lt;/p>
&lt;p>transformer 一次前向计算的 operations 数量大概为&lt;/p>
$$
C_{forward}\approx 2N + 2nLd
$$&lt;p>这里 $L$ 是输入的 token 长度。&lt;/p>
&lt;p>由于反向传播所需要的 FLOPs 是前向传播两倍，因此 transformer 的计算量为&lt;/p>
$$
C = C_{backward} + C_{forward} = 3C_{forward}\approx 6N
$$&lt;p>具体计算过程见 &lt;a class="link" href="https://maosong.website/p/llm-flops-computation/" target="_blank" rel="noopener"
>LLM FLOPs analysis&lt;/a>。也就是说，对于参数量为 $N$ 的 transformer model, 每个 token 所需要的 FLOPs 为 $C\approx 6N$&lt;/p>
&lt;h2 id="empirical-results-and-basic-power-laws">Empirical Results and Basic Power Laws
&lt;/h2>&lt;h3 id="transformer-shape-and-hyper-parameter-independence">Transformer Shape and Hyper-parameter Independence
&lt;/h3>&lt;p>作者基于 $N=12nd^2$, 在保持总参数量 $N$ 不变的情况下，分别调整 $n$, $d_{ff}$ 和 number of attention heads 的个数 （变化 $d$ 用于维持总参数量不变），结果如下图所示&lt;/p>
&lt;p>&lt;img src="https://maosong2022.github.io/p/kaplan-scaling-law/Kaplan-model-shape-ablation.png"
width="1264"
height="501"
srcset="https://maosong2022.github.io/p/kaplan-scaling-law/Kaplan-model-shape-ablation_hu17900088031382528453.png 480w, https://maosong2022.github.io/p/kaplan-scaling-law/Kaplan-model-shape-ablation_hu13532320540752824526.png 1024w"
loading="lazy"
alt="Ablation study on model shape"
class="gallery-image"
data-flex-grow="252"
data-flex-basis="605px"
>&lt;/p>
&lt;p>实验结果发现，损失对于 $d_{ff}/d$, $d/n$, $d/n_h$ 都比较 robust, 说明&lt;strong>模型的损失对模型的 shape 依赖性比较低。&lt;/strong>&lt;/p>
&lt;h3 id="non-embedding-parameter-count">Non-embedding Parameter Count
&lt;/h3>&lt;p>作者探究了以下 model size 对损失的影响，作者使用了不同的 $n$ 和 $d$, 然后训练得到的损失情况如下图所示&lt;/p>
&lt;p>&lt;img src="https://maosong2022.github.io/p/kaplan-scaling-law/Kaplan-ablation-model-size.png"
width="1285"
height="547"
srcset="https://maosong2022.github.io/p/kaplan-scaling-law/Kaplan-ablation-model-size_hu9271102985560927496.png 480w, https://maosong2022.github.io/p/kaplan-scaling-law/Kaplan-ablation-model-size_hu7924636881673413467.png 1024w"
loading="lazy"
alt="Ablation study on model size"
class="gallery-image"
data-flex-grow="234"
data-flex-basis="563px"
>&lt;/p>
&lt;p>作者发现，当包含 embedding parameter 时，损失不仅依赖于模型参数量，还依赖于 layer 层数 $n$, 但是&lt;strong>当我们排除 embedding parameter 时，模型的损失便与 layer 层数 $n$ 关系不大&lt;/strong>。这个趋势可以用以下模型来表示&lt;/p>
$$
L(N) \approx \left(\frac{N_c}{N}\right)^{\alpha_N}
$$&lt;p>最终拟合的曲线如下图所示&lt;/p>
&lt;p>&lt;img src="https://maosong2022.github.io/p/kaplan-scaling-law/Kaplan-parameter-scaling-law-curve.png"
width="404"
height="383"
srcset="https://maosong2022.github.io/p/kaplan-scaling-law/Kaplan-parameter-scaling-law-curve_hu13168868596518131083.png 480w, https://maosong2022.github.io/p/kaplan-scaling-law/Kaplan-parameter-scaling-law-curve_hu5245681849934050002.png 1024w"
loading="lazy"
alt="Scaling law with respect to parameters"
class="gallery-image"
data-flex-grow="105"
data-flex-basis="253px"
>&lt;/p>
&lt;h3 id="comparing-to-lstms-and-universal-transformers">Comparing to LSTMs and Universal Transformers
&lt;/h3>&lt;p>作者比较了 LSTM 和 Transformer 结构的损失，结果如下图所示&lt;/p>
&lt;p>&lt;img src="https://maosong2022.github.io/p/kaplan-scaling-law/Kaplan-ablation-LSTM.png"
width="1268"
height="467"
srcset="https://maosong2022.github.io/p/kaplan-scaling-law/Kaplan-ablation-LSTM_hu1136860397266232918.png 480w, https://maosong2022.github.io/p/kaplan-scaling-law/Kaplan-ablation-LSTM_hu10097496253072581529.png 1024w"
loading="lazy"
alt="Ablation study on LSTM"
class="gallery-image"
data-flex-grow="271"
data-flex-basis="651px"
>&lt;/p>
&lt;p>可以看到，&lt;strong>transformer 比 LSTM 拥有更强的学习能力&lt;/strong>， LSTM 架构对于 early context 表现比较好，但是随着 context 增加，LSTM 的表现逐渐弱于 transformer. &lt;strong>即 transformer 的长上下文能力强于 LSTM 架构&lt;/strong>。&lt;/p>
&lt;h3 id="generalization-among-data-distributions">Generalization Among Data Distributions
&lt;/h3>&lt;p>模型是在 WebText2 数据集上训练的，作者进一步在其他数据集上评估了以下模型的泛化性，结果如下图所示&lt;/p>
&lt;p>&lt;img src="https://maosong2022.github.io/p/kaplan-scaling-law/Kaplan-parameter-scaling-law-generalization.png"
width="1266"
height="591"
srcset="https://maosong2022.github.io/p/kaplan-scaling-law/Kaplan-parameter-scaling-law-generalization_hu4153651653083461167.png 480w, https://maosong2022.github.io/p/kaplan-scaling-law/Kaplan-parameter-scaling-law-generalization_hu2666664858330362694.png 1024w"
loading="lazy"
alt="Generalization performance"
class="gallery-image"
data-flex-grow="214"
data-flex-basis="514px"
>&lt;/p>
&lt;p>结果发现，模型在其他数据集上的泛化性很好。并且，&lt;strong>模型的泛化性能仅与训练阶段的表现相关（validation loss），而与训练阶段（是否收敛）无关&lt;/strong>。&lt;/p>
&lt;p>作者还评估了 model depth 对模型泛化性的影响，结果如下图所示&lt;/p>
&lt;p>&lt;img src="https://maosong2022.github.io/p/kaplan-scaling-law/Kaplan-ablation-depth-to-generalization.png"
width="658"
height="421"
srcset="https://maosong2022.github.io/p/kaplan-scaling-law/Kaplan-ablation-depth-to-generalization_hu3862238373047661970.png 480w, https://maosong2022.github.io/p/kaplan-scaling-law/Kaplan-ablation-depth-to-generalization_hu15572690613863877083.png 1024w"
loading="lazy"
alt="Ablation study on depth"
class="gallery-image"
data-flex-grow="156"
data-flex-basis="375px"
>&lt;/p>
&lt;p>实验结果显示，&lt;strong>model depth 对模型泛化性基本没有影响&lt;/strong>。&lt;/p>
&lt;h3 id="performance-with-data-size-and-compute">Performance with Data Size and Compute
&lt;/h3>&lt;p>作者探究了损失与 dataset size $D$ 之间的关系。作者固定一个模型，然后当 test loss 不再下降时停止训练，结果发现 test loss 与 dataset size $D$ 之间存在如下关系&lt;/p>
$$
L(D) \approx \left(\frac{D_c}{D}\right)^{\alpha_D}
$$&lt;p>拟合结果如下图所示&lt;/p>
&lt;p>&lt;img src="https://maosong2022.github.io/p/kaplan-scaling-law/Kaplan-dataset-size-scaling-law.png"
width="419"
height="384"
srcset="https://maosong2022.github.io/p/kaplan-scaling-law/Kaplan-dataset-size-scaling-law_hu14553376488015908882.png 480w, https://maosong2022.github.io/p/kaplan-scaling-law/Kaplan-dataset-size-scaling-law_hu7074269476621454165.png 1024w"
loading="lazy"
alt="Scaling law with respect to dataset"
class="gallery-image"
data-flex-grow="109"
data-flex-basis="261px"
>&lt;/p>
&lt;p>接下来，基于前面计算的结果，我们有 $C\approx 6ND=6NBS$, 这里 $B$ 是 batch size, $S$ 是训练步数。给定 $C$, 作者使用不同大小的模型进行训练，batch size $B$ 保持不懂，训练步数设置为 $S=C/6BS$,实验结果显示损失与算力 $C$ 之间满足如下关系&lt;/p>
$$
L(C) \approx \left(\frac{C_c}{C}\right)^{\alpha_C}
$$&lt;p>拟合结果如下图所示&lt;/p>
&lt;p>&lt;img src="https://maosong2022.github.io/p/kaplan-scaling-law/Kaplan-compute-scaling-law.png"
width="451"
height="384"
srcset="https://maosong2022.github.io/p/kaplan-scaling-law/Kaplan-compute-scaling-law_hu10913539496339843682.png 480w, https://maosong2022.github.io/p/kaplan-scaling-law/Kaplan-compute-scaling-law_hu13622587868165539120.png 1024w"
loading="lazy"
alt="Scaling law with respect to compute"
class="gallery-image"
data-flex-grow="117"
data-flex-basis="281px"
>&lt;/p>
&lt;p>作者进一步探究了 sample efficiency 与 model size 之间的关系，实验结果如下图所示&lt;/p>
&lt;p>&lt;img src="https://maosong2022.github.io/p/kaplan-scaling-law/Kaplan-sample-efficiency-vs-model-size.png"
width="1273"
height="513"
srcset="https://maosong2022.github.io/p/kaplan-scaling-law/Kaplan-sample-efficiency-vs-model-size_hu12183487265673740051.png 480w, https://maosong2022.github.io/p/kaplan-scaling-law/Kaplan-sample-efficiency-vs-model-size_hu10795984610073713790.png 1024w"
loading="lazy"
alt="Sample efficiency with respect to model size"
class="gallery-image"
data-flex-grow="248"
data-flex-basis="595px"
>&lt;/p>
&lt;p>结果显示，&lt;strong>随着 model size 增加，sample efficiency 也在增加&lt;/strong>&lt;/p>
&lt;h2 id="charting-the-infinite-data-limit-and-overfitting">Charting the Infinite Data Limit and Overfitting
&lt;/h2>&lt;p>作者在本节探讨了同时变化 $N$ 和 $D$ 对损失变化的影响。&lt;/p>
&lt;h3 id="proposed-equation">Proposed Equation
&lt;/h3>&lt;p>作者基于三个原则进行建模：&lt;/p>
&lt;ol>
&lt;li>改变 vocabulary size 或者 tokenization 会 rescale loss&lt;/li>
&lt;li>固定 $D$ 并且令 $N\to\infty$, 则最终损失应该接近 $L(D)$. 反之固定 $N$, 令 $D\to\infty$, 最终损失应该接近 $L(N)$&lt;/li>
&lt;li>$L(N,D)$ 在 $D=\infty$ 处应该是可解析的&lt;/li>
&lt;/ol>
&lt;p>基于以上三条原则，将模型选择为如下形式&lt;/p>
$$
L(N,D) = \left[\left(\frac{N_c}{N}\right)^{\frac{\alpha_N}{\alpha_D}}+ \frac{D_c}{D}\right]^{\alpha_D}
$$&lt;p>作者基于不同配置进行训练，基于实验结果你和得到的参数如下&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Parameter&lt;/th>
&lt;th>$\alpha_N$&lt;/th>
&lt;th>$\alpha_D$&lt;/th>
&lt;th>$N_c$&lt;/th>
&lt;th>$D_c$&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Value&lt;/td>
&lt;td>0.076&lt;/td>
&lt;td>0.103&lt;/td>
&lt;td>$6.4\times 10^{13}$&lt;/td>
&lt;td>$1.8\times 10^{13}$&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>接下来，作者探究了模型的过拟合程度，作者定义如下 metric&lt;/p>
$$
\delta L(N,D) := \frac{L(N,D)}{L(N,\infty)} - 1
$$&lt;p>带入 $L(N,D)$ 定义就得到&lt;/p>
$$
\delta L(N,D) = \left(1 + \left(\frac{N}{N_c}\right)^{\frac{\alpha_N}{\alpha_D}}\frac{D_c}{D}\right) - 1
$$&lt;p>通过测试不同的模型，作者发现 $\delta L$ 的值在 $0.02$ 左右，将实验结果带入到上面的公式就得到&lt;/p>
$$
D \geq (5\times 10^3)N^{0.7379}
$$&lt;p>也就是说对于参数量为 $N$ 的模型，需要 data size $D \geq (5\times 10^3)N^{0.7379}$ 才能避免过拟合。&lt;/p>
&lt;h2 id="scaling-laws-with-model-size-and-training-time">Scaling Laws with Model Size and Training time
&lt;/h2>&lt;p>作者在本节构建了损失函数与 model size $N$ 以及训练时间的 scaling law&lt;/p>
&lt;h3 id="adjustment-for-training-at-critical-batch-size">Adjustment for Training at Critical Batch Size
&lt;/h3>&lt;p>已有结论说明，存在一个 critical batch size $B_{crit}$, 当 batch size 接近 $B_{crit}$ 时，增加 batch size 对计算效率影响比较小，但是当 batch size 大于 $B_{crit}$ 时，带来的提升比较小。另一方面，batch size 会影响梯度的噪声程度。因此，训练步数 $S$ 和处理的样本数 $E=BS$ 应该满足：&lt;/p>
$$
\left(\frac{S}{S_{\min}}-1\right)\left(\frac{E}{E_{\min}}-1\right) = 1
$$&lt;p>这里 $S_{\min}$ 是达到损失 $L$ 所需要的最小训练步数，而 $E_{\min}$ 是最小的训练样本数量。&lt;/p>
&lt;p>作者的实验结果如下&lt;/p>
&lt;p>&lt;img src="https://maosong2022.github.io/p/kaplan-scaling-law/Kaplan-critical-batch-size-relation.png"
width="1264"
height="499"
srcset="https://maosong2022.github.io/p/kaplan-scaling-law/Kaplan-critical-batch-size-relation_hu14217156308397777485.png 480w, https://maosong2022.github.io/p/kaplan-scaling-law/Kaplan-critical-batch-size-relation_hu15617822732658331116.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="253"
data-flex-basis="607px"
>&lt;/p>
&lt;p>作者将 critical batch size 定义为&lt;/p>
$$
B_{crit}(L) := \frac{E_{\min}}{S_{\min}}
$$&lt;p>使用 critical batch size 进行训练可以在计算效率和算力之间达到一个平衡。&lt;/p>
&lt;p>作者基于上面的实验结果探究了 critical batch size 和 model performance 之间的关系，实验结果如下图所示&lt;/p>
&lt;p>&lt;img src="https://maosong2022.github.io/p/kaplan-scaling-law/Kaplan-critical-batch-size-vs-performance.png"
width="946"
height="620"
srcset="https://maosong2022.github.io/p/kaplan-scaling-law/Kaplan-critical-batch-size-vs-performance_hu9889472903970816050.png 480w, https://maosong2022.github.io/p/kaplan-scaling-law/Kaplan-critical-batch-size-vs-performance_hu12246504925174554762.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="152"
data-flex-basis="366px"
>&lt;/p>
&lt;p>可以看到，critical batch size 与 model size 的关系不大，仅与损失 $L$ 有关。作者通过以下模型拟合 critical batch size:&lt;/p>
$$
B_{crit}(L) \approx \frac{B_*}{L^{1/\alpha_B}}
$$&lt;p>这里 $B_*\approx 2\times 10^8$, $\alpha_B\approx 0.21$.&lt;/p>
&lt;p>给定一个 target loss $L$, 当 batch size $B&amp;raquo; B_{crit}$ 时，作者定义最小训练步数为&lt;/p>
$$
S_{\min}(S) := \frac{S}{1+B_{crit}(L)/B}
$$&lt;p>给定 target loss $L$ 和 model size $N$, 当 batch size $B&amp;laquo; B_{crit}$ 时，作者定义最小算力为&lt;/p>
$$
C_{\min}(C) := \frac{C}{1+B_{crit}(L)/B}
$$&lt;h3 id="performance-with-model-size-and-compute">Performance with Model Size and Compute
&lt;/h3>&lt;p>作者使用如下公式来探究损失与 model size 和 computer 之间的关系&lt;/p>
$$
L(N, S_{\min}) = \left(\frac{N_C}{N}\right)^{\alpha_N} +\left(\frac{S_C}{S_{\min}(S)}\right)^{\alpha_S}
$$&lt;p>拟合结果如下表所示&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Parameter&lt;/th>
&lt;th>$\alpha_N$&lt;/th>
&lt;th>$\alpha_S$&lt;/th>
&lt;th>$N_c$&lt;/th>
&lt;th>$S_c$&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Value&lt;/td>
&lt;td>0.077&lt;/td>
&lt;td>0.76&lt;/td>
&lt;td>$6.5\times 10^{13}$&lt;/td>
&lt;td>$2.1\times 10^{3}$&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>基于这个拟合结果，作者得到了下图的结果&lt;/p>
&lt;p>&lt;img src="https://maosong2022.github.io/p/kaplan-scaling-law/Kaplan-loss-vs-model-size-and-training-steps.png"
width="613"
height="347"
srcset="https://maosong2022.github.io/p/kaplan-scaling-law/Kaplan-loss-vs-model-size-and-training-steps_hu4947734139461952958.png 480w, https://maosong2022.github.io/p/kaplan-scaling-law/Kaplan-loss-vs-model-size-and-training-steps_hu13550666530688042403.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="176"
data-flex-basis="423px"
>&lt;/p>
&lt;p>作者还使用了不同的可视化方式，如下图所示&lt;/p>
&lt;p>&lt;img src="https://maosong2022.github.io/p/kaplan-scaling-law/Kaplan-performance-vs-compute-budget-and-steps.png"
width="1273"
height="560"
srcset="https://maosong2022.github.io/p/kaplan-scaling-law/Kaplan-performance-vs-compute-budget-and-steps_hu1733705209026617313.png 480w, https://maosong2022.github.io/p/kaplan-scaling-law/Kaplan-performance-vs-compute-budget-and-steps_hu17479915844925270087.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="227"
data-flex-basis="545px"
>&lt;/p>
&lt;p>实验结果显示，上面的公式拟合的很好。&lt;/p>
&lt;h3 id="lower-bound-on-early-stopping-step">Lower Bound on Early Stopping step
&lt;/h3>&lt;p>作者还探究了以下 early step 与模型大小以及数据集之间的关系，作者通过分析得到如下结果&lt;/p>
$$
S_{stop}(N,D) \gtrsim \frac{S_c}{[L(N,D)-L(N,\infty)]^{1/\alpha_S}}
$$&lt;p>其中 $L(N,\infty)$ 是在充分大数据集上的收敛损失。作者对实验结果进行了拟合，结果如下图所示&lt;/p>
&lt;p>&lt;img src="https://maosong2022.github.io/p/kaplan-scaling-law/Kaplan-early-stop-resultes.png"
width="1277"
height="618"
srcset="https://maosong2022.github.io/p/kaplan-scaling-law/Kaplan-early-stop-resultes_hu5805543562140428933.png 480w, https://maosong2022.github.io/p/kaplan-scaling-law/Kaplan-early-stop-resultes_hu1969578989997728403.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="206"
data-flex-basis="495px"
>&lt;/p>
&lt;h2 id="optimal-allocation-of-the-compute-budget">Optimal Allocation of the Compute Budget
&lt;/h2>&lt;p>作者在本节探究了最优算力与 model size $N$ 和训练数据 $2B_{crit}S_{\min}$ 之间的关系&lt;/p>
&lt;h3 id="optimal-performance-and-allocations">Optimal Performance and Allocations
&lt;/h3>&lt;p>作者首先基于&lt;/p>
$$
C_{\min}(C) := \frac{C}{1+B_{crit}(L)/B}
$$&lt;p>绘制了如下曲线图&lt;/p>
&lt;p>&lt;img src="https://maosong2022.github.io/p/kaplan-scaling-law/Kaplan-loss-vs-optimal-compute.png"
width="664"
height="439"
srcset="https://maosong2022.github.io/p/kaplan-scaling-law/Kaplan-loss-vs-optimal-compute_hu2624240290987422757.png 480w, https://maosong2022.github.io/p/kaplan-scaling-law/Kaplan-loss-vs-optimal-compute_hu3026233000259484535.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="151"
data-flex-basis="363px"
>&lt;/p>
&lt;p>作者发现，相比于 loss 与算力 $C$ 之间的关系，使用 $C_{\min}$ 进行拟合效果更好。&lt;/p>
&lt;p>接下来，作者基于 $L(C_{\min})$ 进一步探究了给定算力如何决定最优的 model size $N(C_{\min})$. 其实验结果如下图所示&lt;/p>
&lt;p>&lt;img src="https://maosong2022.github.io/p/kaplan-scaling-law/Kaplan-optimal-model-size-given-compute.png"
width="616"
height="405"
srcset="https://maosong2022.github.io/p/kaplan-scaling-law/Kaplan-optimal-model-size-given-compute_hu6766491787863314706.png 480w, https://maosong2022.github.io/p/kaplan-scaling-law/Kaplan-optimal-model-size-given-compute_hu13721565017444583805.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="152"
data-flex-basis="365px"
>&lt;/p>
&lt;p>实验结果显示，model size 和算力之间有如下关系&lt;/p>
$$
N(C_{\min}) \propto (C_{\min})^{0.73}
$$&lt;p>作者进一步探究了对于非最优模型大小与算力之间的关系，作者先构建了如下的关系&lt;/p>
$$
\frac{C(N, N_{\mathrm{eff}})}{C(N_{\mathrm{eff}}, N_{\mathrm{eff}})}
= \frac{N}{N_{\mathrm{eff}}}
\left[
1 + \frac{\alpha_S}{\alpha_N}
\left( 1 - \left( \frac{N_{\mathrm{eff}}}{N} \right)^{\alpha_N} \right)
\right]^{-\!1 / \alpha_S}.
$$&lt;p>对应的示意图为&lt;/p>
&lt;p>&lt;img src="https://maosong2022.github.io/p/kaplan-scaling-law/Kaplan-suboptimal-model-efficiency.png"
width="1256"
height="600"
srcset="https://maosong2022.github.io/p/kaplan-scaling-law/Kaplan-suboptimal-model-efficiency_hu3403526838017537494.png 480w, https://maosong2022.github.io/p/kaplan-scaling-law/Kaplan-suboptimal-model-efficiency_hu18252056355401133900.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="209"
data-flex-basis="502px"
>&lt;/p>
&lt;p>实现结果发现，大小为最优模型的 $0.6\sim 2.2$ 倍只需要额外 $20%$ 的算力。作者强调，这个实验结果对于超大模型不一定适用。&lt;/p>
&lt;p>作者进一步推导了 $S_{\min}$ 和 $C_{\min}$ 之间的关系，由于 $C_{\min}=6NB_{crit}S$, 且我们前面已经有 $B\propto L^{-4.8}$ 和 $L\propto C_{\min}^{-0.05}$, 因此 我们有&lt;/p>
$$
B_{crit}\propto L^{-4.8} \propto (C_{\min})^{-0.05\times (-4.8)}\propto (C_{\min})^{0.24}
$$&lt;p>以及&lt;/p>
$$
S_{\min} \propto \frac{C_{\min}}{6B_{crit}N(C_{\min})} \propto (C_{\min})^{0.03}
$$&lt;p>拟合的结果如下图所示&lt;/p>
&lt;p>&lt;img src="https://maosong2022.github.io/p/kaplan-scaling-law/Kaplan-optimal-step-size-vs-compute.png"
width="620"
height="403"
srcset="https://maosong2022.github.io/p/kaplan-scaling-law/Kaplan-optimal-step-size-vs-compute_hu17458715235703264140.png 480w, https://maosong2022.github.io/p/kaplan-scaling-law/Kaplan-optimal-step-size-vs-compute_hu15917017864681204094.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="153"
data-flex-basis="369px"
>&lt;/p>
&lt;p>因此，基于上面的结果，当我们增加算力时，我们的主要精力应该放在增加模型大小和提高 batch size 上，而训练步数基本可以保持不变。&lt;/p>
&lt;h3 id="another-way-of-derivation">Another way of Derivation
&lt;/h3>&lt;p>作者还给出了另一种建模 $L(C_{\min})$ 的方式，即从 $L(N,S_{\min})$ 中进行推导，作者将 $B_{crit}$ 和 $S_{\min}$ 的表达式带入到 $L(N,S_{\min})$ 然后求解最小值就得到&lt;/p>
$$
L(C_{\min})= \left(\frac{C_C^{\min}}{C_{\min}}\right)^{\alpha_C^{\min}}
$$&lt;p>其中&lt;/p>
$$
\alpha_C^{\min} = \frac{1}{\frac{1}{\alpha_S}+\frac{1}{\alpha_B}+\frac{1}{\alpha_N}} \approx 0.054
$$&lt;p>这和前面的结果基本是吻合的，进一步进行推导得到&lt;/p>
$$
N(C_{\min})\propto (C_{\min})^{\alpha_C^{\min}/\alpha_N}\approx (C_{\min})^{0.71}
$$&lt;p>这个结果也和上面的差不多。&lt;/p>
&lt;h3 id="contradiction-and-a-conjecture">Contradiction and a Conjecture
&lt;/h3>&lt;p>作者发现，尽管拟合的 scaling law 曲线非常好，但是由于自然语言不可能达到 zero entropy, 因此该曲线最终一定会失效。作者基于更大的模型进行了实验，结果发现，模型在某一点开始就比预测的损失曲线下降的更慢。作者认为这是因为 transformer 模型已经达到了 maximal performance 导致的。&lt;/p>
&lt;p>通过前面的分析，我们发现 $L(C_{\min})$ 比 $L(D)$ 下降的快，因此两者必然在某一点相交。&lt;/p>
&lt;p>在前面的章节中，我们基于以下关系来决定数据集大小&lt;/p>
$$
D\propto N^{0.74}\propto (C_{\min})^{0.74*0.73}\propto (C_{\min})^{0.54}
$$&lt;p>这里我们利用了 $N(C_{\min})$ 的结果&lt;/p>
&lt;p>另一方面，我们有&lt;/p>
$$
D(C_{\min}) = \frac{2C_{\min}}{6N(C_{\min})}\propto (C_{\min})^{0.26}
$$&lt;p>可以看到，基于训练最优导出的数据集大小相比于拟合出来的数据集大小，实际上存在过拟合。&lt;/p>
&lt;p>作者进一步分析出了 $L(D(C_{\min}))$ 和 $L(C_{\min})$ 这两条曲线的交点，结果得到&lt;/p>
$$
C^*\approx 10^4 \text{ PF-Days}, N^*\approx 10^{12}\text{ parameters}, D^*\approx 10^12\text{ tokens}, L^*\approx 1.7\text{1.7nats/token}
$$&lt;p>作者认为出现这种原因有以下几种情况：&lt;/p>
&lt;ol>
&lt;li>$L^*$ 给出了自然语言的 entropy 的一个估计，因此当模型充分大之后，模型可能已经获取到了数据中的所有知识&lt;/li>
&lt;li>$L(C_{\min})$ 可以作为数据集噪声的一个量化表现，其衡量了数据集的质量&lt;/li>
&lt;/ol>
&lt;h2 id="learning-rate-schedule">Learning Rate Schedule
&lt;/h2>&lt;p>附录中，作者还探究了 learning rate 与损失之间的关系，作者使用了不同 learning rate schedule 对模型损失的影响，结果如下图所示&lt;/p>
&lt;p>&lt;img src="https://maosong2022.github.io/p/kaplan-scaling-law/Kaplan-learning-rate-schedule-results.png"
width="1278"
height="530"
srcset="https://maosong2022.github.io/p/kaplan-scaling-law/Kaplan-learning-rate-schedule-results_hu13606754496324356115.png 480w, https://maosong2022.github.io/p/kaplan-scaling-law/Kaplan-learning-rate-schedule-results_hu4951923550844399163.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="241"
data-flex-basis="578px"
>&lt;/p>
&lt;p>实验结果显示，&lt;strong>只要 learning rate 下降的不会太快，模型的表现基本上差不太多&lt;/strong>。&lt;/p>
&lt;p>作者基于实验结果得到了学习率和模型参数之间的关系如下&lt;/p>
$$
\text{lr}(N)\approx 0.003239 - 0.0001395\log N
$$&lt;p>也就是说，小模型用比较大的学习率，大模型用较小的学习率。&lt;/p>
&lt;h2 id="conclusion">Conclusion
&lt;/h2>&lt;p>作者在本文中训练了大量不同配置的大模型，然后构建了损失（损失）与模型参数，数据及大小以及算力之间的关系。实验结果发现，损失与架构和优化参数之间的关系比较小，主要由模型参数量决定，更大的模型拥有更高的采样效率。&lt;/p>
&lt;p>作者认为，本文的局限在于损失函数不一定能够反应模型在其他语言任务上的表现。&lt;/p>
&lt;h2 id="references">References
&lt;/h2>&lt;ul>
&lt;li>&lt;a class="link" href="http://arxiv.org/abs/2001.08361" target="_blank" rel="noopener"
>arxiv&lt;/a>&lt;/li>
&lt;/ul></description></item></channel></rss>